First we have to introduce matrices and vectors and the rules for multiplication. Every matrix has a _transpose_\(A^{\mathrm{T}}\). This matrix has an _inverse_\(A^{-1}\).
3. In most cases elimination goes forward without difficulties. The matrix has an inverse and the system \(Ax=b\) has one solution. In exceptional cases the method will _break down_--either the equations were written in the wrong order, which is easily fixed by exchanging them, or the equations don't have a unique solution. That _singular case_ will appear if 8 replaces 5 in our example: \[\begin{array}{ccccccc}\textbf{Singular case}&&1x&+&2y&=&3\\ \textbf{Two parallel lines}&&4x&+&8y&=&6.\end{array}\] (7) Elimination still innocently subtracts 4 times the first equation from the second. But look at the result! \[(\textbf{equation 2})-4(\textbf{equation 1})\qquad 0=-6.\] This singular case has _no solution_. Other singular cases have _infinitely many solutions_. (Change 6 to 12 in the example, and elimination will lead to \(0=0\). Now \(y\) can have _any value_,) When elimination breaks down, we want to find every possible solution.
4. We need a rough count of the _number of elimination steps_ required to solve a system of size \(n\). The computing cost often determines the accuracy in the model. A hundred equations require a third of a million steps (multiplications and subtractions). The computer can do those quickly, but not many trillions. And already after a million steps, roundoff error could be significant. (Some problems are sensitive; others are not.) Without trying for full detail, we want to see large systems that arise in practice, and how they are actually solved.

The final result of this chapter will be an elimination algorithm that is about as efficient as possible. It is essentially the algorithm that is in constant use in a tremendous variety of applications. And at the same time, understanding it in terms of _matrices_--the coefficient matrix \(A\), the matrices \(E\) for elimination and \(P\) for row exchanges, and the

Figure 1.1: The example has one solution. Singular cases have none or too many.

 